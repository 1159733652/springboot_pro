# 工程简介
    一、Infrastructure
    改造 Controller 层逻辑
    统一返回结构
        统一返回值类型无论项目前后端是否分离都是非常必要的，
    方便对接接口的开发人员更加清晰地知道这个接口的调用是否成
    功（不能仅仅简单地看返回值是否为 null 就判断成功与否，
    因为有些接口的设计就是如此），使用一个状态码、状态信息就
    能清楚地了解接口调用情况
    统一包装处理
        Spring 中提供了一个类 ResponseBodyAdvice ，能
        帮助我们实现上述需求
        ResponseBodyAdvice 是对 Controller 返回的内
        容在 HttpMessageConverter 进行类型转换之前拦截，
        进行相应的处理操作后，再将结果返回给客户端。那这样就
        可以把统一包装的工作放到这个类里面。
    参数校验
        Java API 的规范 JSR303 定义了校验的标准 validation-api ，
        其中一个比较出名的实现是 hibernate validation ，
        spring validation 是对其的二次封装，
        常用于 SpringMVC 的参数自动校验，
        参数校验的代码就不需要再与业务逻辑代码进行耦合了。
        @PathVariable 和 @RequestParam 参数校验
            Get 请求的参数接收一般依赖这两个注解，
            但是处于 url 有长度限制和代码的可维护性，超过 5 个参数尽量用实体来传参
            对 @PathVariable 和 @RequestParam 
            参数进行校验需要在入参声明约束的注解
            如果校验失败，会抛出 MethodArgumentNotValidException 异常
    自定义校验规则
        有些时候 JSR303 标准中提供的校验规则不满足复杂的业务需求，
        也可以自定义校验规则
        自定义校验规则需要做两件事情
            自定义注解类，定义错误信息和一些其他需要的内容
            注解校验器，定义判定规则
    自定义异常与统一拦截异常
        原来的代码中可以看到有几个问题
        抛出的异常不够具体，只是简单地把错误信息放到了 Exception 中
        抛出异常后，Controller 不能具体地根据异常做出反馈
        虽然做了参数自动校验，但是异常返回结构和正常返回结构不一致
        自定义异常是为了后面统一拦截异常时，对业务中的异常有更加细颗粒度的区分，拦截时针对不同的异常作出不同的响应
        而统一拦截异常的目的一个是为了可以与前面定义下来的统一包装返回结构能对应上，另一个是我们希望无论系统发生什么异常，
        Http 的状态码都要是 200 ，尽可能由业务来区分系统的异常
    总结
        做好了这一切改动后，可以发现 Controller 的代码变得非常简洁，
        可以很清楚地知道每一个参数、每一个 DTO 的校验规则，
        可以很明确地看到每一个 Controller 方法返回的是什么数据，
        也可以方便每一个异常应该如何进行反馈

        这一套操作下来后，我们能更加专注于业务逻辑的开发，
        代码简洁、功能完善，何乐而不为呢？
# 延伸阅读

